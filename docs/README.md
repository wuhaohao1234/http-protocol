# 从输入URL到页面加载的过程

> 由一道题完善自己的前端知识体系

## 目录

1. 从浏览器接收url到开启网络请求线程(浏览器的机制以及进程与线程之间的关系)

2. 开启网络线程到发出一个完整的http请求(dns查询,tcp/ip请求,五层因特网协议)

3. 从服务器接收到请求到对应后台接收到请求(负载均衡,安全拦截以及后台内部:查询数据库，服务端渲染或者客户端渲染)

4. 后台和前台的http交互(http头部、响应码、报文结构、cookie,常用工具的例如swagger)

5. http缓存

6. 浏览器接收到http数据包后的解析流程(dom树渲染，render树,回流(也叫重排)或者重绘,GPU绘制，外链资源(css,img,js,font,video,docs))

7. css可视化格式(元素的渲染规则，如包含块，控制框，BFC，IFC等概念)

8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）

## 一、从浏览器接收url到开启网络请求线程

### 1、多进程的浏览器

    一个程序(例如qq))可以有多个进程,一个进程可以有多个线程去干不同的事

    浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）。

    进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等。

* Browser进程：浏览器的主进程（负责协调、主控），只有一个

    - 负责浏览器界面显示，与用户交互。如前进，后退等
    - 负责各个页面的管理，创建和销毁其他进程
    - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
    - 网络资源的管理，下载等

* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建(例如chrome中的vue进程)

* GPU进程：最多一个，用于3D绘制

* 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

#### 1.1、浏览器多进程的优势(缺点是占内存)

* 避免单个page crash影响整个浏览器
* 避免第三方插件crash影响整个浏览器
* 多进程充分利用多核优势
* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

### 2、多线程的浏览器内核

    每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：

* GUI渲染线程

    - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
    - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow，也叫重排)时，该线程就会执行
    - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

* JS引擎线程(这也是说js引擎是单线程的原因)
    - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
    - JS引擎线程负责解析Javascript脚本，运行代码。
    - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    - 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
* 事件触发线程(这里也是浏览器中的同步与异步的原因)

    - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
    - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
    - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

* 定时器线程

    - 传说中的setInterval与setTimeout所在线程
    - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

* 异步http请求线程

    - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

#### 2.1、Browser进程和浏览器内核（Renderer进程）的通信过程

1. Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程

2. Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染

    * 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染

    * 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）

    * 最后Render进程将结果传递给Browser进程

    * Browser进程接收到结果并将结果绘制出来

#### 2.2、梳理浏览器内核中线程之间的关系

##### 2.2.1、GUI渲染线程与JS引擎线程互斥

由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了

因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，

GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

###### 2.2.2、JS阻塞页面加载

假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。
然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。

###### 2.2.3、WebWorker，JS的多线程

    Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

    一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 

    这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window

    因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误

1. 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）

2. JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）

如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，
只待计算出结果后，将结果通信给主线程即可

###### 2.2.4、WebWorker与SharedWorker

    本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

1. WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享

    * 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。

2. SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
    * 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。

##### 2.2.5浏览器渲染流程

    1. 浏览器输入url，浏览器主进程接管，开一个下载线程，
    然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
    随后将内容通过RendererHost接口转交给Renderer进程

    2. 浏览器渲染流程开始

浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：

1. 解析html建立dom树

2. 解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）

3. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

4. 绘制render树（paint），绘制页面像素信息

5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了

###### 2.2.6、load事件与DOMContentLoaded事件的先后

1. 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。

2. 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。

    顺序DOMContentLoaded -> load

##### 2.2.7、css加载是否会阻塞dom树渲染

1. css加载不会阻塞DOM树解析（异步加载时DOM照常构建）

2. 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

##### 2.2.8、普通图层和复合图层

渲染步骤中就提到了composite概念。

首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）

其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。

然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源
（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒

* 如何变成复合图层（硬件加速）

    1. 最常用的方式：translate3d、translateZ

    2. opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）

    3. will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），

##### 2.2.9、absolute和硬件加速的区别

absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，
但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。
（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）

而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层
（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）

##### 2.2.10、复合图层的作用

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能

但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡

##### 2.2.11、硬件加速时请使用index

    使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染

原理:

**webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能**

##### 2.2.12 从Event Loop谈JS的运行机制

* JS分为同步任务和异步任务

* 同步任务都在主线程上执行，形成一个执行栈

* 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。

* 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

###### 2.2.13、定时器

    浏览器中的定时器线程：当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。

##### 2.2.14、用setTimeout模拟定期计时和直接用setInterval是有区别的。

    每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差（误差多少与代码执行时间有关）

    而setInterval则是每次都精确的隔一段时间推入一个事件（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）

setInterval有一些比较致命的问题就是：

* 累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。
就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）

* 而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame

##### 2.2.15、事件循环进阶：macrotask与microtask(宏任务与微任务)
    es6中的Promise里有了一个一个新的概念：microtask

* macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
    - 每一个task会从头到尾将这个任务执行完毕，不会执行其它
    - 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
* microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务

    - 也就是说，在当前task任务后，下一个task之前，在渲染之前
    - 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
    - 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）
* macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）

* microtask：Promise，process.nextTick等

* 在node环境下，process.nextTick的优先级高于Promise__，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。

**线程的理解**

* macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护

* microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护

**执行机制**

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

**Promise的polyfill与官方版本的区别：**

* 官方版本中，是标准的microtask形式
* polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式


### 3、解析url

    URL一般包括几大部分：

* protocol，协议头，譬如有http，https，ftp等

* host，主机域名或IP地址

* port，端口号

* path，目录路径

* query，即查询参数

* fragment，即 #后的hash值，一般用来定位到某个位置

### 4、网络请求都是单独的线程

    每次网络请求时都需要开辟单独的线程进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载。

    因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）。

## 二、开启网络线程到发出一个完整的http请求

### 2.1、DNS查询得到IP

如果输入的是域名，需要进行dns解析成IP，大致流程：

* 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host

* 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP

**域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）。**

例如:https://www.jsdelivr.com/，这个网站上面有好多github,npm的资源镜像

需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch优化。

### 2.3、tcp/ip请求

http的本质就是 tcp/ip请求。

需要了解3次握手规则建立连接以及断开连接时的四次挥手。

tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。

### 2.4、三次握手的步骤建立连接

* 客户端：hello，你是server么？

* 服务端：hello，我是server，你是client么

* 客户端：yes，我是client

### 2.5、四次挥手的步骤断开连接

* 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了

* 被动方：收到通道关闭的信息

* 被动方：那我也告诉你，我这边向你的主动通道也关闭了

* 主动方：最后收到数据，之后双方无法通信

### 2.6、tcp/ip的并发限制

* 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）。

* 而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求。

* 所以针对这个瓶颈，又出现了很多的资源优化方案。

### 2.7、get和post的区别

* get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。

* get会产生一个tcp数据包，post两个。

具体

* get请求时，浏览器会把 headers和 data一起发送出去，服务器响应200（返回数据）

* post请求时，浏览器先发送 headers，服务器响应 100continue，浏览器再发送 data，服务器响应200（返回数据）。

这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现）

### 2.8、五层因特网协议栈

总体概念:从客户端发出http请求到服务器接收，中间会经过一系列的流程。

从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

### 2.8、五层因特尔协议栈

1. 应用层(dns,http) DNS解析成IP并发送http请求
2. 传输层(tcp,udp) 建立tcp连接（三次握手）
3. 网络层(IP,ARP) IP寻址
4. 数据链路层(PPP) 封装成帧
5. 物理层(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）

当然，其实也有一个完整的OSI七层框架，与之相比，多了会话层、表示层。

* 表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等

* 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程

## 三、从服务器接收到请求到对应后台接收到请求

### 3.1负载均衡

对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡。

用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户。

### 3.2后台的处理

一般后台都是部署到容器中的(例如:docker)，所以一般为：

* 先是容器接受到请求（如tomcat容器）

* 然后对应容器中的后台程序接收到请求（如java程序）

* 然后就是后台会有自己的统一处理，处理完后响应响应结果

概括

1. 一般有的后端是有统一的验证的，如安全拦截(一些是属于前端，在表单方面)，跨域验证(这里指的是cors，通过request.header设置)

2. 如果这一步不符合规则，就直接返回了相应的http报文（如拒绝请求等）

3. 然后当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）

4. 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）

5. 然后就是将这个包从后端发送到前端，完成交互

## 四、后台和前台的http交互(常见的工具例如swagger)

    前后端交互时，http报文作为信息的载体。所以http是一块很重要的内容，这一部分重点介绍它。

### 4.1、http报文结构

    报文一般包括了： 通用头部， 请求/响应头部， 请求/响应体。

#### 4.1.1、通用头部

1. Request Url: 请求的web服务器地址

2. Request Method: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）

3. Status Code: 请求的返回状态码，如200代表成功，304缓存

4. Remote Address: 请求的远程服务器地址（会转为IP）

在跨域拒绝时，可能是method为 options，状态码为 404/405等（当然，实际上可能的组合有很多）。

其中，Method的话一般分为两批次：

* HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
2. HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。

最常用到的就是状态码，很多时候都是通过状态码来判断

* 200——表明该请求被成功地完成，所请求的资源发送回客户端

* 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存

* 400——客户端请求有错（譬如可以是安全模块拦截）

* 401——请求未经授权

* 403——禁止访问（譬如可以是未登录时禁止）

* 404——资源未找到

* 500——服务器内部错误

* 503——服务不可用

大致不同范围状态的意义

* 1xx——指示信息，表示请求已接收，继续处理

* 2xx——成功，表示请求已被成功接收、理解、接受

* 3xx——重定向，要完成请求必须进行更进一步的操作

* 4xx——客户端错误，请求有语法错误或请求无法实现

* 5xx——服务器端错误，服务器未能实现合法的请求

3. 请求/响应头部

    - Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）

    - Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收

    - Content-Type：客户端发送出去实体内容的类型

    - Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache

    - If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中

    - Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间

    - Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中

    - If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中

    - Cookie：有cookie并且同域访问时会自动带上

    - Connection：当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive

    - Host：请求的服务器URL

    - Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私

    - Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)

    - User-Agent：用户客户端的一些必要信息，如UA头部等

4. 常用的响应头部（部分）

* Access-Control-Allow-Headers: 服务器端允许的请求Headers

* Access-Control-Allow-Methods: 服务器端允许的请求方法

* Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）

* Content-Type：服务端返回的实体内容的类型

* Date：数据从服务器发送的时间

* Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档

* Last-Modified：请求资源的最后修改时间

* Expires：应该在什么时候认为文档已经过期,从而不再缓存它

* Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效

* ETag：请求变量的实体标签的当前值

* Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端

* Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）

* Server：服务器的一些相关信息

一般来说，请求头部和响应头部是匹配分析的。

譬如，请求头部的 Accept要和响应头部的 Content-Type匹配，否则会报错。

譬如，跨域请求时，请求头部的 Origin要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误。

譬如，在使用缓存时，请求头部的 If-Modified-Since、 If-None-Match分别和响应头部的 Last-Modified、 ETag对应。

#### 4.2请求/响应实体

http请求时，除了头部，还有消息实体，一般来说，请求实体中会将一些需要的参数都放入进入（用于post请求）。譬如实体中可以放参数的序列化形式（ a=1&b=2这种），或者直接放表单对象（ FormData对象，上传时可以夹杂参数以及文件），等等。

而一般响应实体中，就是放服务端需要传给客户端的内容。一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。

#### 4.3CRLF

CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在。

请求头和实体消息之间有一个CRLF分隔，响应头部和响应实体之间用一个CRLF分隔。

分隔符类别：

* CRLF->Windows-style

* LF->Unix Style

* CR->Mac Style

#### 4.4cookie以及优化

cookie是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的session使用。(cookie不安全，用户就可以看到，一般我们会让cookie有过期的时间)

##### 4.4.1应用场景

* 在登陆页面，用户登陆了

* 此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）

* 然后会有一个sessionid（相当于是服务端的这个session对应的key）

* 然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx

* 然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。

一般来说，cookie是*不允许存放敏感信息*的（千万不要明文存储用户名、密码），因为非常不安全，如果一定要强行存储，首先，一定要在cookie中设置 httponly（这样就无法通过js操作了），另外可以考虑rsa等非对称加密（因为实际上，浏览器本地也是容易被攻克的，并不安全）。

另外，由于在同域名的资源请求时，浏览器会默认带上本地的cookie，针对这种情况，在某些场景下是需要优化的。

譬如以下场景：

* 客户端在域名A下有cookie（这个可以是登陆时由服务端写入的）

* 然后在域名A下有一个页面，页面中有很多依赖的静态资源（都是域名A的，譬如有20个静态资源）

* 此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上cookie

* 也就是说，这20个静态资源的http请求，每一个都得带上cookie，而实际上静态资源并不需要cookie验证

* 这样反而浪费cookie也降低了访问速度

解决办法:

* 将静态资源分组，分别放到不同的子域名下

* 而子域名请求时，是不会带上父级域名的cookie的，所以就避免了浪费

* 在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc,现在都快5g了，移动端网速一般比较好）

* 此时就需要用到一种优化方案： dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）

### 4.5、gzip压缩

gzip是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持），而且gzip压缩效率很好（高达70%左右）。然后gzip一般是由 apache、 tomcat等web服务器开启。

服务器除了gzip外，也还会有其它压缩格式（如deflate，没有gzip高效，且不流行），所以一般只需要在服务器上开启了gzip压缩，然后之后的请求就都是基于gzip压缩格式的，非常方便。

### 4.6、长连接与短连接

* 长连接：一个tcp/ip连接上可以连续发送多个数据包，在tcp连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）

* 短连接：通信双方有数据交互时，就建立一个tcp连接，数据发送完成后，则断开此tcp连接

然后在http层面：

* http1.0中，默认使用的是短连接，也就是说，浏览器没进行一次http操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接

* http1.1起，默认使用长连接，使用长连接会有这一行 Connection:keep-alive，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输http的tcp连接不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接

注意： *keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效。*

### 4.7、http 2.0

http2.0不是https，它相当于是http的下一代规范（譬如https的请求可以是http2.0规范的）。然后简述下http2.0与http1.1的显著不同点：

* http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来

* http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。

如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）。

http2.0的一些特性：

* 多路复用（即一个tcp/ip连接可以请求多个资源）

* 首部压缩（http头部压缩，减少体积）

* 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）

* 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）

* 求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

### 4.8、https:

https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。

简单来看，https与http的区别就是： **在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析**

一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）

一般来说，主要关注的就是SSL/TLS的握手流程，如下（简述）：

1. 浏览器请求建立SSL链接，并向服务端发送一个随机数–Client random和客户端支持的加密方法，比如RSA加密，此时是明文传输。

2. 服务端从中选出一组加密算法与Hash算法，回复一个随机数–Server random，并将自己的身份信息以证书的形式发回给浏览器 （证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）

3. 浏览器收到服务端的证书后

    * 验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示

    * 用户接收证书后（不管信不信任），浏览会生产新的随机数–Premaster secret，然后证书中的公钥以及指定的加密方法加密 Premastersecret，发送给服务器。

    * 利用Client random、Server random和Premaster secret通过一定的算法生成HTTP链接数据传输的对称加密key- session key

    * 使用约定好的HASH算法计算握手消息，并使用生成的 session key对消息进行加密，最后将之前生成的所有信息发送给服务端。

4. 服务端收到浏览器的回复

    * 利用已知的加解密方式与自己的私钥进行解密，获取 Premastersecret
    * 和浏览器相同规则生成 session key
    * 使用 session key解密浏览器发来的握手消息，并验证Hash是否与浏览器发来的一致
    * 使用 session key加密一段握手消息，发送给浏览器

5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，

    之后所有的https通信数据将由之前浏览器生成的 session key并利用对称加密算法进行加密。

## 五、http的缓存

    前后端的http交互中，使用缓存能很大程度上的提升效率，而且基本上对性能有要求的前端项目都是必用缓存的。

### 5.1 强缓存与弱缓存

    缓存可以简单的划分成两种类型： 强缓存（ 200fromcache）与 协商缓存（ 304）。

* 强缓存（ 200fromcache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求

* 协商缓存（ 304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存

对于协商缓存，使用 Ctrl+F5强制刷新可以使得缓存无效。但是对于强缓存，在未过期时，必须更新资源路径才能发起新的请求（更改了路径相当于是另一个资源了，这也是前端工程化中常用到的技巧）。

### 5.2 缓存头部简述

* 强缓存控制
```
(http1.1) Cache-Control/Max-Age
(http1.0) Pragma/Expires
```
* 协商缓存控制
```
(http1.1) Cache-Control/E-tag
(http1.0) Pragma/Last-Modified
```
HTML页面中也有一个meta标签可以控制缓存方案- Pragma。
`<meta HTTP-EQUIV="Prama" CONIENT="no-cache" >`

### 5.3头部的区别

首先明确，http的发展是从http1.0到http1.1，而在http1.1中，出了一些新内容，弥补了http1.0的不足。

http1.0中的缓存控制：

* Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置 no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令，主要是因为兼容http1.0，所以以前又被大量应用）

* Expires：服务端配置的，属于强缓存，用来控制在规定的时间之前，浏览器不会发出请求，而是直接使用本地缓存，注意，Expires一般对应服务器端时间，如 Expires：Fri,30Oct199814:19:41

* If-Modified-Since/Last-Modified：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-Modified-Since，而服务端的是 Last-Modified，它的作用是，在发起请求时，如果 If-Modified-Since和 Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。 Last-Modified，顾名思义，指的是文件最后的修改时间，而且只能精确到 1s以内

http1.1中的缓存控制：

* Cache-Control：缓存控制头部，有no-cache、max-age等多种取值

* Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，注意，Max-Age是Cache-Control头部的值，不是独立的头部，譬如 Cache-Control:max-age=3600，而且它值得是绝对时间，由浏览器自己计算

* If-None-Match/E-tag：这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是 If-None-Match，而服务端的是 E-tag，同样，发出请求后，如果 If-None-Match和 E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于 FileEtagINodeMtimeSize生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。

### 5.4、Max-Age相比Expires

Expires使用的是服务器端的时间，但是有时候会有这样一种情况-客户端时间和服务端不同步。那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期，所以一般http1.1后不推荐使用 Expires。而 Max-Age使用的是客户端本地时间的计算，因此不会有这个问题，因此推荐使用 Max-Age。

注意，如果同时启用了 Cache-Control与 Expires， Cache-Control优先级高。

### 5.5、E-tag相比Last-Modified

Last-Modified：

* 表明服务端的文件最后何时改变的

* 它有一个缺陷就是只能精确到1s，

* 然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效

而 E-tag:

* 是一种指纹机制，代表文件相关指纹

* 只有文件变才会变，也只要文件变就会变，

* 也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了

    如果同时带有 E-tag和 Last-Modified，服务端会优先检查 E-tag。

## 六、解析页面流程

### 6.1 html渲染,构建dom树

1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符

2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集

3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则

4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样。例如：body对象的父节点就是HTML对象

### 6.2 css规则

    将相应的属性样式放在dom树上

### 6.3 render树的构建

    当DOM树和CSSOM都有了后，就要开始构建渲染树了。一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应。因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者 display:none等。

### 6.4、渲染流程

1. 计算css样式

2. 构建渲染树

3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性

4. 绘制，将图像绘制出来

然后，通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）。

Layout和Repaint的概念区别

* Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树

* Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了

回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，所以优化方案中一般都包括，尽量避免回流。

### 6.5、什么会引起回流

1. 页面渲染初始化

2. DOM结构改变，比如删除了某个节点

3. render树变化，比如减少了padding

4. 窗口resize

5. 获取某些属性(width,height)，引发回流。

很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效

1. offset(Top/Left/Width/Height)

2. scroll(Top/Left/Width/Height)

3. cilent(Top/Left/Width/Height)

4. width,height

5. 调用了getComputedStyle()或者IE的currentStyle

回流一定伴随着重绘，重绘却可以单独出现。

1. 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新

2. 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document(没有在页面上展示或者没有添加到body中的，在内存中的dom，均被称为虚拟dom)

3. 避免多次读取offset等属性。无法避免则将它们缓存到变量

4. 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高

**改变字体大小会引发回流**

### 6.6 简单层与复合层

    上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。这里不展开，进简单介绍下：

* 可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的

* 如果开启了硬件加速功能（translate3d,transform），可以将某个节点变成复合图层

* 复合图层之间的绘制互不干扰，由GPU直接控制

* 而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速

### 6.7资源外链的下载

1. 遇到外链时的处理

    遇到css,js,img外链时，会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）。

2. 遇到CSS样式资源

    * CSS下载时异步，不会阻塞浏览器构建DOM树

    * 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）

    * 有例外， media query声明的CSS是不会阻塞渲染的

3. js资源

    * 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML(上文中提到过GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行)

    * 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已

    * defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行*defer是延迟执行，而async是异步执行*

    * async是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 onload前，但不确定在 DOMContentLoaded事件的前或后

    * defer是延迟执行，在浏览器看起来的效果像是将脚本放在了 body后面一样（虽然按规范应该是在 DOMContentLoaded事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）

4. img

    异步加载，不会阻塞

## 七、CSS的可视化格式模型

* CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）

* 然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局

* 换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等

**CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树**

关键字：

* 包含块（Containing Block）

* 控制框（Controlling Box）

* BFC（Block Formatting Context）

* IFC（Inline Formatting Context）

* 定位体系

* 浮动

### 7.1包含块（Containing Block）

一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系。

* 根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块

* static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建

* fixed的包含块是当前可视窗口

* absolute的包含块由它最近的position 属性为 absolute、 relative或者 fixed的祖先元素创建

    * 如果其祖先元素是行内元素，则包含块取决于其祖先元素的 direction特性

    * 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界

### 7.2控制框（Controlling Box）

    块级元素和块框以及行内元素和行框的相关概念。

* 块级元素会生成一个块框（ BlockBox），块框会占据一整行，用来包含子box和生成的内容

* 块框同时也是一个块包含框（ ContainingBox），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围

### 7.3、BFC（Block Formatting Context）

FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如：

* FC像是一个大箱子，里面装有很多元素

* 箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）

* 内部的规则可以是：如何定位，宽高计算，margin折叠等等

不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC。

**并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则。**

#### 7.4.1 BFC规则：

在块格式化上下文中，每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边），即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合），除非这个元素也创建了一个新的BFC。

* 内部 box在垂直方向，一个接一个的放置

* box的垂直方向由 margin决定，属于同一个BFC的两个box间的margin会重叠

* BFC区域不会与 floatbox重叠（可用于排版)

* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此

* 计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）

#### 7.4.2如何触发BFC

1. 根元素

2. float属性不为 none

3. position为 absolute或 fixed

4. display为 inline-block, flex, inline-flex， table， table-cell， table-caption

5. overflow不为 visible

这里提下， display:table，它本身不产生BFC，但是它会产生匿名框（包含 display:table-cell的框），而这个匿名框产生BFC。

#### 7.4.3IFC（Inline Formatting Context）

IFC即行内框产生的格式上下文。

浮动元素可能会处于包含块边缘和行框边缘之间，尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化。

同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本），当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 text-align 特性。空的行内框应该被忽略。

即不包含文本，保留空白符，margin/padding/border非0的行内元素，以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，并且不是以换行结束的行框，必须被当作零高度行框对待。

* 行内元素总是会应用IFC渲染规则

* 行内元素会应用IFC规则渲染，譬如 text-align可以用来居中等

* 块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则

* 行内框内部，对于那些行内元素，一样应用IFC渲染规则

* 另外， inline-block，会在元素外层产生IFC（所以这个元素是可以通过 text-align水平居中的），当然，它内部则按照BFC规则渲染

相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件），但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解。

* IFC规则

在行内格式化上下文中，框一个接一个地水平排列，起点是包含块的顶部。水平方向上的 margin，border 和 padding 在框之间得到保留，框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐。

#### 7.4.5行框

包含那些框的长方形区域，会形成一行，叫做行框。行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定。

行框的规则：

* 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）

* 行框在堆叠时没有垂直方向上的分割且永不重叠

* 行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）

* 行框的左边接触到其包含块的左边，右边接触到其包含块的右边

## 八、JS引擎解析过程

### 8.1 JS的解释阶段

**JS是解释型语音，所以它无需提前编译，而是由解释器实时运行**

引擎对JS的处理过程可以简述如下：

1. 读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）

2. 对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）

3. 使用翻译器（translator），将代码转为字节码（bytecode）

4. 使用字节码解释器（bytecode interpreter），将字节码转为机器码

最终计算机执行的就是机器码。为了提高运行速度，现代浏览器一般采用即时编译（ JIT-JustInTimecompiler）。即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（ inlinecache），这样整个程序的运行速度能得到显著提升。而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）。

*核心的 JIT编译器将源码编译成机器码运行*

### 8.2、JS的预处理阶段

上述将的是解释器的整体过程，这里再提下在正式执行JS前，还会有一个预处理阶段（譬如变量提升，分号补全等）。

预处理阶段会做一些事情，确保JS可以正确执行，这里仅提部分：

1. 分号补全

    JS执行是需要分号的,为什么可以不加分号

    原因就是JS解释器有一个Semicolon Insertion规则，它会按照一定规则，在适当的位置补充分号。

    * 当有换行符（包括含有换行符的多行注释），并且下一个 token没法跟前面的语法匹配时，会自动补分号。

    * 当有 }时，如果缺少分号，会补分号。

    * 程序源代码结束时，如果缺少分号，会补分号。

2. 变量提升

一般包括函数提升和变量提升。

这里由于内容多，如果说的话还得说变量声明，函数声明，形参，实参的优先级顺序，以及es6中let

### 8.3、JS的执行阶段

解释器解释完语法规则后，就开始执行，然后整个执行流程中大致包含以下概念：

* 执行上下文，执行堆栈概念（如全局上下文，当前活动上下文）

* VO（变量对象）和AO（活动对象）

* 作用域链

* this机制

1. 执行上下文简单解释

    * JS有 执行上下文
    * 浏览器首次载入脚本，它将创建 全局执行上下文，并压入执行栈栈顶（不可被弹出）
    * 然后每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部
    * 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
    * 这样依次执行（最终都会回到全局执行上下文）

如果程序执行完毕，被弹出执行栈，然后有没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收。

然后执行上下文与VO。作用域链，this的关系是，每一个执行上下文，都有三个重要属性：

* 变量对象

* 作用域链

* this

2. VO与AO

    VO是执行上下文的属性（抽象概念），但是只有全局上下文的变量对象允许通过VO的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）。

    AO（ activationobject)，当函数被调用者激活，AO就被创建了。

    * 在函数上下文中： VO===AO

    * 在全局上下文中： VO===this===global

    总的来说，VO中会存放一些变量信息（如声明的变量，函数， arguments参数等等）。

3. 作用域链

    它是执行上下文中的一个属性，原理和原型链很相似，作用很重要。

    在函数上下文中，查找一个变量foo，如果函数的VO中找到了，就直接使用，否则去它的父级作用域链中（parent）找。如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错。

4. this指针

*this是执行上下文环境的一个属性，而不是某个变量对象的属性*

* this是没有一个类似搜寻变量的过程

* 当代码中使用了this，这个 this的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻

* this的值只取决中进入上下文时的情况

总结:*this指向调用者与它所处的环境*

### 8.4回收机制

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。一般来说，垃圾处理器有自己的回收策略。譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）。

常用的回收规则:

* 标记清除

* 引用计数

Javascript引擎基础GC方案是（ simple GC）： markandsweep（标记清除），简单解释如下：

1. 遍历所有可访问的对象。

2. 回收已不可访问的对象。

*js高级程序设计*
```
当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。
从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
而当变量离开环境时，则将其标记为“离开环境”。
垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包，也就是说在环境中的以及相关引用的变量会被去除标记）。
而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。
最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
```

#### 8.5引用计数

跟踪记录每个值被引用的次数，当一个值被引用时，次数 +1，减持时 -1，下次垃圾回收器会回收次数为 0的值的内存（当然了，容易出循环引用的bug）。

### 9、GC的缺陷

和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在 100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。

*这就是引擎需要优化的点： 避免GC造成的长时间停止响应*

### 10、GC优化策略

这里介绍常用到的：分代回收（Generation GC）。目的是通过区分“临时”与“持久”对象：

* 多回收“临时对象”区（ young generation）

* 少回收“持久对象”区（ tenured generation）

* 减少每次需遍历的对象，从而减少每次GC的耗时。

像node v8引擎就是采用的分代回收（和java一样，作者是java虚拟机作者。）

## 九、其它

### 跨域:浏览器的同源策略

解决跨域的方案

* cors后端设置(上文提到过)

* jsonp

jsonp只支持get请求,原理是通过script中的src让后端返回一个回调函数

* 反向代理
### web安全

ajax是否安全

### viewport视口的概念(移动端)

## 十、参考链接

https://segmentfault.com/a/1190000012925872

https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/

https://coolshell.cn/articles/9666.html

http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/

http://blog.csdn.net/dojiangv/article/details/51794535

http://bbs.csdn.net/topics/340204423

https://segmentfault.com/a/1190000004246731

http://www.bubuko.com/infodetail-1379568.html

http://fex.baidu.com/blog/2014/05/what-happen/

http://www.cnblogs.com/winter-cn/archive/2013/05/21/3091127.html

https://fanerge.github.io/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-webkit%E5%86%85%E6%A0%B8%E7%A0%94%E7%A9%B6.html

http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html

https://segmentfault.com/q/1010000000489803